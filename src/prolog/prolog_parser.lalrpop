use prolog::ast::*;

use std::cell::Cell;

grammar;

pub TopLevel: TopLevel = {
    "?-" <q:Query> "." => TopLevel::Query(q),
    <Predicate> => TopLevel::Predicate(<>),
    <Rule>  "." => TopLevel::Rule(<>),
    <Term>  "." => TopLevel::Fact(<>)
};

Atom : Atom = {
    r"[a-z][A-Za-z0-9_]*" => <>.trim().to_string(),
};

BoxedTerm : Box<Term> = {
    <t:Term> => Box::new(t)
};

Call : QueryTerm = {
    "call" "(" <a:Atom> "(" <ts: (<BoxedTerm> ",")*> <t:BoxedTerm> ")"
    <tss: ("," <BoxedTerm>)*> ")" => {
        let mut ts  = ts;
        let mut tss = tss;

	ts.push(t);

        ts.append(&mut tss);
        QueryTerm::Term(Term::Clause(Cell::default(), a, ts))
    },
    "call" "(" <a:Atom> <ts: ("," <BoxedTerm>)*> ")" =>        
        QueryTerm::Term(Term::Clause(Cell::default(), a, ts)),    
    "call" "(" <v:Var> <ts: ("," <BoxedTerm>)*> ")" =>
        QueryTerm::CallN(Cell::default(), v, ts)
};

Clause : Term = {
    <a:Atom> "(" <ts: (<BoxedTerm> ",")*> <t:BoxedTerm> ")" => {
     	let mut ts = ts;
     	ts.push(t);
	Term::Clause(Cell::default(), a, ts)
    }
};

List : Term = {
    "[]" => Term::Constant(Cell::default(), Constant::EmptyList),
    "[" <ListInternals> "]" => <>
};

ListInternals : Term = {
    <t:BoxedTerm> => Term::Cons(Cell::default(),
                                t,
				Box::new(Term::Constant(Cell::default(),
				                        Constant::EmptyList))),
    <t:BoxedTerm>  "," <li: ListInternals> => Term::Cons(Cell::default(),
                                                         t,
							 Box::new(li)),
    <t1:BoxedTerm> "|" <t2:BoxedTerm> => Term::Cons(Cell::default(), t1, t2)
};

Predicate : Vec<PredicateClause> = {
    <pcs: (<PredicateClause>)+> <pc: PredicateClause> => {
        let mut pcs = pcs;
	pcs.push(pc);
	pcs
    }
};

PredicateClause : PredicateClause = {
    <Rule> "." => PredicateClause::Rule(<>),
    <Term> "." => PredicateClause::Fact(<>)
};

Query : Vec<QueryTerm> = {
    <tcs: (<QueryTerm> ",")*> <tc: QueryTerm> => {
        let mut tcs = tcs;
        tcs.push(tc);
        tcs
    }
};

Rule : Rule = {
    <c:Clause> ":-" <h:QueryTerm> <cs: ("," <QueryTerm>)*> =>
        Rule { head: (c, h), clauses: cs },
    <a:Atom> ":-" <h:QueryTerm> <cs: ("," <QueryTerm>)*> =>
        Rule { head: (Term::Constant(Cell::default(), Constant::Atom(a)),
	              h),
               clauses: cs }
};

QueryTerm : QueryTerm = {
    <Call>   => <>,
    "!"      => QueryTerm::Cut,
    <Var>    => QueryTerm::CallN(Cell::default(), <>, Vec::new()),
    <Clause> => QueryTerm::Term(<>),
    <Atom>   => QueryTerm::Term(Term::Constant(Cell::default(), Constant::Atom(<>)))
};

Term : Term = {
    <Atom>   => Term::Constant(Cell::default(), Constant::Atom(<>)),
    <Clause> => <>,
    <List>   => <>,
    <Var>    => Term::Var(Cell::default(), <>),
    "_"      => Term::AnonVar
};

Var : Var = {
    r"[A-Z][A-Za-z0-9_]*" => <>.trim().to_string()
};